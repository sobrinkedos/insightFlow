name: Backup Produ√ß√£o

on:
  # Execu√ß√£o di√°ria √†s 2h AM (UTC)
  schedule:
    - cron: '0 2 * * *'
  
  # Permite execu√ß√£o manual
  workflow_dispatch:
    inputs:
      backup_type:
        description: 'Tipo de backup'
        required: false
        default: 'manual'
        type: choice
        options:
          - manual
          - daily
          - pre_migration
  
  # Trigger via webhook ap√≥s migra√ß√£o
  repository_dispatch:
    types: [migration-completed]

jobs:
  backup:
    name: Backup do Banco de Produ√ß√£o
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Instalar depend√™ncias
        run: npm ci
      
      - name: Setup PostgreSQL Client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      
      - name: Verificar vers√£o do PostgreSQL
        run: psql --version
      
      - name: Criar diret√≥rio de backup
        run: mkdir -p backups
      
      - name: Gerar timestamp
        id: timestamp
        run: echo "timestamp=$(date +%Y%m%d_%H%M%S)" >> $GITHUB_OUTPUT
      
      - name: Determinar tipo de backup
        id: backup_type
        run: |
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "type=daily" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "type=pre_migration" >> $GITHUB_OUTPUT
          else
            echo "type=${{ github.event.inputs.backup_type || 'manual' }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Desabilitar IPv6
        run: |
          echo "üîß Desabilitando IPv6..."
          sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1
          sudo sysctl -w net.ipv6.conf.default.disable_ipv6=1
          echo "‚úÖ IPv6 desabilitado"
      
      - name: Exportar banco de produ√ß√£o
        env:
          PROD_DB_URL: ${{ secrets.PROD_SUPABASE_DB_URL }}
        run: |
          echo "üîÑ Exportando banco de produ√ß√£o..."
          BACKUP_FILE="backups/backup_${{ steps.timestamp.outputs.timestamp }}.sql"
          
          # Extrair host da URL
          DB_HOST=$(echo "$PROD_DB_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p')
          echo "Host: $DB_HOST"
          
          # Resolver DNS para IPv4 apenas
          DB_IP=$(dig +short "$DB_HOST" A | head -n1)
          echo "Resolved IPv4: $DB_IP"
          
          # Se n√£o conseguiu resolver, usar o hostname
          if [ -z "$DB_IP" ]; then
            echo "‚ö†Ô∏è N√£o conseguiu resolver IP, usando hostname"
            FINAL_URL="$PROD_DB_URL"
          else
            # Substituir hostname por IP na URL
            FINAL_URL=$(echo "$PROD_DB_URL" | sed "s/@${DB_HOST}/@${DB_IP}/")
            echo "URL com IP: ${FINAL_URL/@*:*@/@[IP]:*@}"
          fi
          
          # Executar pg_dump com timeout
          timeout 300 pg_dump "$FINAL_URL" \
            --format=plain \
            --no-owner \
            --no-acl \
            --clean \
            --if-exists \
            --file="$BACKUP_FILE"
          
          echo "‚úÖ Backup exportado: $BACKUP_FILE"
          echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT
        id: export
      
      - name: Verificar tamanho do backup
        id: size
        run: |
          SIZE_BYTES=$(stat -f%z "${{ steps.export.outputs.backup_file }}" 2>/dev/null || stat -c%s "${{ steps.export.outputs.backup_file }}")
          SIZE_MB=$(echo "scale=2; $SIZE_BYTES / 1048576" | bc)
          echo "size_mb=$SIZE_MB" >> $GITHUB_OUTPUT
          echo "üìä Tamanho do backup: ${SIZE_MB}MB"
      
      - name: Importar para banco de backup
        env:
          BACKUP_DB_URL: ${{ secrets.BACKUP_SUPABASE_DB_URL }}
        run: |
          echo "üîÑ Importando para banco de backup..."
          
          # Extrair host da URL
          DB_HOST=$(echo "$BACKUP_DB_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p')
          echo "Host: $DB_HOST"
          
          # Resolver DNS para IPv4 apenas
          DB_IP=$(dig +short "$DB_HOST" A | head -n1)
          echo "Resolved IPv4: $DB_IP"
          
          # Se n√£o conseguiu resolver, usar o hostname
          if [ -z "$DB_IP" ]; then
            echo "‚ö†Ô∏è N√£o conseguiu resolver IP, usando hostname"
            FINAL_URL="$BACKUP_DB_URL"
          else
            # Substituir hostname por IP na URL
            FINAL_URL=$(echo "$BACKUP_DB_URL" | sed "s/@${DB_HOST}/@${DB_IP}/")
            echo "URL com IP: ${FINAL_URL/@*:*@/@[IP]:*@}"
          fi
          
          # Executar psql com timeout
          timeout 300 psql "$FINAL_URL" < "${{ steps.export.outputs.backup_file }}"
          
          echo "‚úÖ Backup importado com sucesso"
      
      - name: Verificar integridade do backup
        env:
          PROD_DB_URL: ${{ secrets.PROD_SUPABASE_DB_URL }}
          BACKUP_DB_URL: ${{ secrets.BACKUP_SUPABASE_DB_URL }}
        run: |
          echo "üîç Verificando integridade..."
          
          # Conta registros em tabelas principais (exemplo)
          PROD_COUNT=$(psql "$PROD_DB_URL" -t -c "SELECT COUNT(*) FROM public.migration_history" | tr -d ' ')
          BACKUP_COUNT=$(psql "$BACKUP_DB_URL" -t -c "SELECT COUNT(*) FROM public.migration_history" | tr -d ' ')
          
          echo "Produ√ß√£o: $PROD_COUNT registros"
          echo "Backup: $BACKUP_COUNT registros"
          
          if [ "$PROD_COUNT" = "$BACKUP_COUNT" ]; then
            echo "‚úÖ Integridade verificada"
            echo "verified=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Contagens diferentes - verifica√ß√£o manual necess√°ria"
            echo "verified=false" >> $GITHUB_OUTPUT
          fi
        id: verify
      
      - name: Registrar backup no hist√≥rico
        env:
          BACKUP_DB_URL: ${{ secrets.BACKUP_SUPABASE_DB_URL }}
        run: |
          echo "üìù Registrando backup no hist√≥rico..."
          
          psql "$BACKUP_DB_URL" <<EOF
          INSERT INTO public.backup_history (
            type,
            size_mb,
            status,
            source_environment,
            verification_status,
            retention_until,
            metadata
          ) VALUES (
            '${{ steps.backup_type.outputs.type }}',
            ${{ steps.size.outputs.size_mb }},
            'completed',
            'production',
            '${{ steps.verify.outputs.verified }}',
            NOW() + INTERVAL '30 days',
            '{"github_run_id": "${{ github.run_id }}", "timestamp": "${{ steps.timestamp.outputs.timestamp }}"}'::jsonb
          );
          EOF
          
          echo "‚úÖ Backup registrado"
      
      - name: Limpar backups antigos
        env:
          BACKUP_DB_URL: ${{ secrets.BACKUP_SUPABASE_DB_URL }}
        run: |
          echo "üßπ Limpando backups expirados..."
          
          psql "$BACKUP_DB_URL" <<EOF
          -- Marcar backups expirados
          UPDATE public.backup_history
          SET status = 'expired'
          WHERE retention_until < NOW()
            AND status = 'completed';
          EOF
          
          echo "‚úÖ Limpeza conclu√≠da"
      
      - name: Enviar notifica√ß√£o de sucesso
        if: success()
        run: |
          echo "‚ú® Backup conclu√≠do com sucesso!"
          echo "Tipo: ${{ steps.backup_type.outputs.type }}"
          echo "Tamanho: ${{ steps.size.outputs.size_mb }}MB"
          echo "Verificado: ${{ steps.verify.outputs.verified }}"
      
      - name: Enviar notifica√ß√£o de falha
        if: failure()
        run: |
          echo "‚ùå Backup falhou!"
          echo "Verifique os logs para mais detalhes"
          # Aqui voc√™ pode adicionar integra√ß√£o com Slack, email, etc.
      
      - name: Upload do arquivo de backup (opcional)
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: backup-${{ steps.timestamp.outputs.timestamp }}
          path: ${{ steps.export.outputs.backup_file }}
          retention-days: 7

  notify:
    name: Notificar Status
    needs: backup
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Verificar status
        run: |
          if [ "${{ needs.backup.result }}" = "success" ]; then
            echo "‚úÖ Backup conclu√≠do com sucesso"
          else
            echo "‚ùå Backup falhou - a√ß√£o necess√°ria"
          fi
